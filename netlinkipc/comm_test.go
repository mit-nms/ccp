// +build ignore

// TODO getting "connection refused"

package netlinkipc

import (
	"fmt"
	"golang.org/x/sys/unix"
	"testing"
	"time"

	"ccp/ipcBackend"

	log "github.com/Sirupsen/logrus"
	"github.com/mdlayher/netlink"
)

// This example demonstrates using a netlink.Conn to listen for multicast group
// messages generated by the addition and deletion of network interfaces.
func TestComm(t *testing.T) {
	ready := make(chan interface{})
	done1 := make(chan error)
	done2 := make(chan error)

	t.Log("starting recv")
	go recv(ready, done1)
	select {
	case <-ready:
	case err := <-done1:
		t.Error(err)
		return
	}

	t.Log("starting send")
	go send(done2)

	err := <-done2
	if err != nil {
		t.Error(err)
		return
	}
	t.Log("send done")

	err = <-done1
	t.Log("recv done")
	if err != nil {
		t.Error(err)
		return
	}
}

func send(done chan error) {
	nl, err := netlink.Dial(
		unix.NETLINK_USERSOCK,
		&netlink.Config{
			Groups: 0,
		},
	)
	if err != nil {
		log.WithFields(log.Fields{
			"where": "send setup",
		}).Warn(err)
		done <- err
		return
	}

	sk := New()
	akMsg := sk.GetAckMsg()
	akMsg.New(4, 42, time.Millisecond)

	buf, err := akMsg.Serialize()
	if err != nil {
		done <- err
		return
	}

	resp := netlink.Message{
		Header: netlink.Header{
			Flags: netlink.HeaderFlagsRequest | netlink.HeaderFlagsAcknowledge,
		},
		Data: buf,
	}

	_, err = nl.Send(resp)
	log.WithFields(log.Fields{
		"where": "after send",
	}).Warn(err)
	done <- err
}

func recv(ready chan interface{}, done chan error) {
	nl, err := New().SetupListen("", 33).SetupFinish()
	if err != nil {
		log.WithFields(log.Fields{
			"where": "recv setup",
		}).Warn(err)
		done <- err
		return
	}

	ready <- struct{}{}

	msgs := nl.Listen()
	msg := <-msgs

	log.WithFields(log.Fields{
		"msg": msg,
	}).Info("got msg")

	switch msg.(type) {
	case ipcbackend.AckMsg:
		ack := msg.(ipcbackend.AckMsg)
		if ack.SocketId() == 4 && ack.AckNo() == 42 && ack.Rtt() == time.Millisecond {
			done <- nil
		} else {
			done <- fmt.Errorf("expected (4, 42, 1ms) got (%v, %v, %v)", ack.SocketId(), ack.AckNo(), ack.Rtt())
		}
	default:
		done <- fmt.Errorf("expected AckMsg got %v", msg)
	}
}
